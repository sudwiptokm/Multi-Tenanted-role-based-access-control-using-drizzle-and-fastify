'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var cast = {
  string_to_number: function string_to_number(value) {
    return Number(value);
  },
  string_to_boolean: function string_to_boolean(value) {
    return value === 'true';
  },
  undefined_to_string: function undefined_to_string(value) {
    return value;
  },
  undefined_to_number: function undefined_to_number(value) {
    return Number(value);
  },
  undefined_to_boolean: function undefined_to_boolean(value) {
    return value === 'true';
  }
};
// @ts-ignore
function set(obj, prop, value) {
  return obj[prop] = value;
}
var main = function main(_ref) {
  var _ref$dotenv = _ref.dotenv,
    dotenv = _ref$dotenv === void 0 ? true : _ref$dotenv,
    schema = _ref.schema,
    data = _ref.data;
  var processEnv = data || process.env;
  if (dotenv) {
    var _dotenv = require('dotenv');
    _dotenv.config();
  }
  var shape = schema.shape;
  var keys = Object.keys(shape);
  var envKeys = Object.keys(processEnv);
  var result = {};
  for (var _i = 0, _envKeys = envKeys; _i < _envKeys.length; _i++) {
    var key = _envKeys[_i];
    if (keys.includes(key)) {
      result[key] = processEnv[key];
    }
  }
  var env = schema.safeParse(result);
  if (env.success) {
    return env.data;
  }
  var errors = env.error;
  for (var _iterator = _createForOfIteratorHelperLoose(errors.errors), _step; !(_step = _iterator()).done;) {
    var error = _step.value;
    var path = error.path[0];
    if (error.code === 'invalid_type') {
      var fnPath = error.received + "_to_" + error.expected;
      var fn = cast[fnPath];
      if (!fn) {
        console.error(error);
        throw new Error("No cast function for " + fnPath + " - " + path);
      }
      var value = fn(result[path]);
      set(result, path, value);
    }
  }
  return schema.parse(result);
};

exports.default = main;
exports.main = main;
//# sourceMappingURL=zennv.cjs.development.js.map
